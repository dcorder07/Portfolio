# -*- coding: utf-8 -*-
"""Bayes Implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16OJYU-oIzpAgf2N4k5OcPE7Qy_g3Lk2Z
"""

import pandas as pd
import numpy as np
from ucimlrepo import fetch_ucirepo
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from pgmpy.models import BayesianNetwork
from pgmpy.estimators import MaximumLikelihoodEstimator
from sklearn.metrics import accuracy_score, classification_report
from pgmpy.inference import VariableElimination

# Fetch dataset
adult = fetch_ucirepo(id=2)

# Data (as pandas dataframes)
X = adult.data.features.copy()
y = adult.data.targets

if isinstance(y, pd.DataFrame):
    y = y.iloc[:, 0]

X.replace('?', np.nan, inplace=True)

# Fill in missing values using mode
for column in ['workclass', 'occupation', 'native-country']:
    mode_value = X[column].mode()[0]
    X[column] = X[column].fillna(mode_value)

# Convert data to numerical using one-hot encoding
columns_to_encode = ['workclass', 'marital-status', 'occupation', 'relationship', 'race', 'sex', 'native-country']
X_encoded = pd.get_dummies(X, columns=columns_to_encode)

# Drop unnecessary columns
X_encoded = X_encoded.drop(columns=['education', 'fnlwgt'])

# Convert target column to binary format
y = y.str.replace('.', '', regex=False)
y = y.map({'<=50K': 0, '>50K': 1}).astype(int)
#y = y.fillna(0).astype(int)

X_encoded = X_encoded.astype(float)
y = y.astype(int)

# hyper parameter
# evaluating the model with different sizes of training and testing data
split_sizes = [0.2, 0.25, 0.3, 0.35, 0.4]

# Loop over each split size
for test_size in split_sizes:
    print(f"\nEvaluating with test size: {test_size}")

    # Split the data with the current test size
    X_train, X_test, y_train, y_test = train_test_split(X_encoded, y, test_size=test_size, random_state=42)

    # Use SMOTE to balance the training data
    smote = SMOTE(sampling_strategy='auto', random_state=42)
    X_train_balanced, y_train_balanced = smote.fit_resample(X_train, y_train)

    # Define the Bayesian Network structure
    model = BayesianNetwork([
        ('capital-gain', 'income'),
        ('income', 'marital-status_Married-civ-spouse'),
        ('income', 'relationship_Own-child'),
        ('income', 'marital-status_Never-married'),
        ('income', 'capital-loss'),
        ('income', 'occupation_Priv-house-serv'),
        ('income', 'relationship_Other-relative'),
        ('income', 'native-country_Columbia'),
        ('income', 'native-country_Guatemala'),
        ('income', 'workclass_Never-worked')])

    # Fit the model using MaximumLikelihoodEstimator
    model.fit(pd.concat([X_train_balanced, y_train_balanced], axis=1), estimator=MaximumLikelihoodEstimator)

    inference = VariableElimination(model)

    # Filter the test set to only include relevant features
    # here we find the intersection between the model's nodes and the feature names in X_test
    model_nodes = set(model.nodes())
    X_test_filtered = X_test.loc[:, list(model_nodes.intersection(X_test.columns))]

    print(X_test_filtered)

    encoded_columns = X_encoded.columns.tolist()

    predictions = []
    for _, row in X_test_filtered.iterrows():
        filtered_evidence = {}


        for key, value in row.items():
            if key in model_nodes and not pd.isna(value):

                if value == 1:
                    filtered_evidence[key] = 1
                else:
                    filtered_evidence[key] = 0

        try:
            prob = inference.map_query(variables=['income'], evidence=filtered_evidence)
            predictions.append(prob['income'])
        except Exception as e:
            print(f"Inference failed for row: {filtered_evidence}\nError: {e}")
            predictions.append(0)  # Default class if inference fails

    # Evaluate the model performance
    accuracy = accuracy_score(y_test, predictions)
    print(f"Test Size: {test_size}, Accuracy: {accuracy}")
    print(f"Classification Report for Test Size {test_size}:\n", classification_report(y_test, predictions))
    print("-" * 50)